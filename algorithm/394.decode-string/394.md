## 394. 字符串解码

```
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

 

示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"
示例 2：

输入：s = "3[a2[c]]"
输出："accaccacc"
示例 3：

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
示例 4：

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

本体属于有思路+没思路
* 有思路，*大概*知道是需要recursive，一个函数call另一个函数
* 没思路，除了recursive，就没有任何想法了

会纠结于细节，如果decode `[]`,如果是多层嵌套怎么办，如果多层嵌套加多孩子怎么办，把自己多思路陷进了无限多细节里边。


所以我按照没思路来走SSH

* Smaller
    * 
* Similar
    * 38. Count and Say
    * 有点像树的问题![394](./graphs/394.drawio.svg),
* High level
    * 假设子问题已经解决

综合以上描述，对于测试用例 3[a2[c]]，假设F(1) = [a2[c]], F(1)已经解决，我们知道结果就是F(1)F(1)F(1)重复3遍
而F(1)同样可解 F(1) = a2[c], 假设F(2) = a[c],假设F(2)已经解决，那么F(1) = aF(2)F(2).

显而易见，父问题依赖子问题，子问题解出来之前，当子问题得到解答，父问题就有足够的信息解出来。这就是top down的recursive,

当然，此处还有一些技术上的难点，如何找出配对`[]`，如果找出数字


```java
class Solution {
    public String decodeString(String s) {
        int num = decodeNumber(s);
        String childStr = decodeChildString(s);
        StringBuilder sb = new StringBuilder();
        String child = decodeString(childStr);
        while(num-->0) {
            sb.append(child);
        }
        return sb.toString();
    }

    private int decodeNumber(String s) {
        int i = 0;
        for(; i < s.length(); i++>) {
            if(s.charAt(i) == '[') {
                break;
            }
        }
        return Integer.valueOf(s.substring(0, i));
    }

    private int decodeChildString(String s) {
        int i = 0, j = s.length()-1;
        while(s.charAt(i) != '['){
            i++;
        }
        while(s.charAt(j) != ']') {
            j--;
        }
        return s.substring(i+1, j);
    }
}
```

上边的解法不对，为什么，看例子`3[a]2[bc]`，这种*想*出来的解法会在某一个case没有处理。原因就是没有明白这道题目。这道题相似的就是表达式求值`1*5+4*(2+15*5+4/2)`，几乎一样的题型

如果能想到这个题目是表达式求值，那么问题就迎刃而解，扫描表达式，一个op stack和一个num stack，处理运算符的precedent，然后入栈，出栈，计算求值

具体算法描述如下：
* 构造辅助栈stack，遍历字符串的每个字符c
    * 如果c是数字,更新multi，cur_multi
    * 如果c是字母，更新res，这个是last_res
    * c = '['，入栈multi和res,重制multi和res
    * c = ']'，res = last_res + cur_multi * res
        * last_res是上个 [ 到当前 [ 的字符串，例如 "3[a2[c]]" 中的 a
        * cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 "3[a2[c]]" 中的 2

```
* step 1

    3[a2[c]]
    ^
    c

    stack: 
    res:
    multi: 3

* Step 2

    3[a2[c]]
     ^
     c

    stack: (3, "")
    res:
    multi: 0

* Step3

    3[a2[c]]
      ^
      c

    stack: (3, "")
    res: "a"
    multi: 0    

* Step4

    3[a2[c]]
       ^
       c

    stack: (3, "")(2, "a")
    res: "a"
    multi: 2    

* Step5

    3[a2[c]]
        ^
        c

    stack: (3, "")(2, "a")
    res: ""
    multi: 0

* Step6

    3[a2[c]]
         ^
         c

    stack: (3, "")(2, "a")
    res: "c"
    multi: 0    

* Step7

    3[a2[c]]
          ^
          c

    stack: (3, "")(2, "a")
    res: "acc"
    multi: 0        

* Step9

    3[a2[c]]
           ^
           c

    stack: 
    res: "accaccacc"
    multi: 0     
```